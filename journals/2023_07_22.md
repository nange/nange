- [[Linux性能优化]] [[CPU上下文切换]]：
	- 每个任务在执行时都有一组相关的CPU寄存器的状态，这就是任务的上下文。当CPU从一个任务切换到另一个任务时，需要保存当前任务的上下文，然后恢复下一个任务的上下文，这个过程就是上下文切换。
	- 具体来说，上下文切换包括以下步骤：
		- 保存当前任务的状态（上下文）：包括程序计数器，寄存器，虚拟内存信息等。
		- 加载新任务的状态（上下文）：从新任务的任务控制块（TCB）中读取其上下文，并加载到CPU的寄存器中。
		- 更新任务调度器的状态：将新任务设置为当前运行的任务。
	- 上下文切换是有开销的，包括CPU时间和系统资源，因此，频繁的上下文切换可能会导致系统性能下降。
	- **进程上下文切换：**
		- 系统调用（也被称作软中断）：
			- 进程运行空间分为用户空间和内核空间。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。
			- 从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。
			- 系统调用的过程会发生CPU上下文切换。
				- 为了执行内核态代码，CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。
				- 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。
				- 不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。
		- 进程切换和系统调用的区别：
			- 进程是由内核来管理和调度的，进程的切换只能发生在内核态。
			- 进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。
	- **线程上下文切换：**
		- 分两种情况：
			- 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。
			- 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。
		- 由此可见进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。
	- **(硬)中断上下文切换：**
		- 中断也会切换CPU上下文。
		- 为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。
		-
	- **怎么查看系统的上下文切换情况：**
		- `vmstat` 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。
			- ```
			  # 每隔5秒输出1组数据
			  $ vmstat 5
			  procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
			   r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
			   0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0
			  ```
			- 重点关注4列：
				- cs（context switch）：是每秒上下文切换的次数。
				- in（interrupt）：则是每秒中断的次数。
				- r（Running or Runnable）：是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
				- b（Blocked）：则是处于不可中断睡眠状态的进程数。
		- `vmstat` 用于分析系统整体的情况，如果想分析具体某个进程的上下文切换情况，需要使用之前提到过的`pidstat` 加上`-w`参数。
			- ```
			  # 每隔5秒输出1组数据
			  $ pidstat -w 5
			  Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)
			  
			  08:18:26      UID       PID   cswch/s nvcswch/s  Command
			  08:18:31        0         1      0.20      0.00  systemd
			  08:18:31        0         8      5.40      0.00  rcu_sched
			  ...
			  ```
			- cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。
			- 它们意味着不同的性能问题：
				- 自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
				- 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
			- `pidstat -w`默认是显示进程的上下文切换，如果要显示线程的，还需要加上`-t`参数：
				- ```
				  # 每隔1秒输出一组数据（需要 Ctrl+C 才结束）
				  # -wt 参数表示输出线程的上下文切换指标
				  $ pidstat -wt 1
				  08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command
				  ...
				  08:14:05        0     10551         -      6.00      0.00  sysbench
				  08:14:05        0         -     10551      6.00      0.00  |__sysbench
				  08:14:05        0         -     10552  18911.00 103740.00  |__sysbench
				  08:14:05        0         -     10553  18915.00 100955.00  |__sysbench
				  08:14:05        0         -     10554  18827.00 103954.00  |__sysbench
				  ...
				  ```
		- 查看具体的中断类型，可以从 `/proc/interrupts` 这个只读文件中读取。如
			- ```
			  # -d 参数表示高亮显示变化的区域
			  $ watch -d cat /proc/interrupts
			             CPU0       CPU1
			  ...
			  RES:    2450431    5279697   Rescheduling interrupts
			  ...
			  ```