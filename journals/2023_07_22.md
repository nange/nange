- [[Linux性能优化]] [[CPU上下文切换]]：
	- 每个任务在执行时都有一组相关的CPU寄存器的状态，这就是任务的上下文。当CPU从一个任务切换到另一个任务时，需要保存当前任务的上下文，然后恢复下一个任务的上下文，这个过程就是上下文切换。
	- 具体来说，上下文切换包括以下步骤：
		- 保存当前任务的状态（上下文）：包括程序计数器，寄存器，虚拟内存信息等。
		- 加载新任务的状态（上下文）：从新任务的任务控制块（TCB）中读取其上下文，并加载到CPU的寄存器中。
		- 更新任务调度器的状态：将新任务设置为当前运行的任务。
	- 上下文切换是有开销的，包括CPU时间和系统资源，因此，频繁的上下文切换可能会导致系统性能下降。
	- **进程上下文切换：**
		- 系统调用：
			- 进程运行空间分为用户空间和内核空间。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。
			- 从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。
			- 系统调用的过程会发生CPU上下文切换。
				- 为了执行内核态代码，CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。
				- 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。
				- 不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。
			- 进程切换和系统调用的区别：
				- 进程是由内核来管理和调度的，进程的切换只能发生在内核态。
				- 进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。
-
-