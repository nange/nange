tags:: tcp

- [[TCP]]是可以双向通信的，其关闭也需要经典的四次挥手过程，分为半关闭和全关闭状态，在代码层面，也有几个方法和其对应，以[[Go]]语言为例包含：`TCPConn.Close(), TCPConn.CloseRead(), TCPConn.CloseWrite()`，那系统底层的四次挥手(半关闭和全关闭)又是如何影响代码的编写的呢？经过测试有如下结论：
	- 对于一般的HTTP服务来说，通常我们只需要在业务逻辑都处理完时，统一调用一次连接的`Close`方法即可，对于客户端和服务端都是这样。在系统层面，调用`Close`方法就是向对方发送`FIN`包，告诉对方自己关闭了，然后完成四次挥手，即结束本次连接
	- 那`CloseRead`和`CloseWrite`方法又是做什么的呢？和`Close`方法又有什么区别和联系呢？
		- 一些特定的应用基于某些特定的目的，可能会提前调用`CloseRead`或者`CloseWrite`方法
		- 对于客户端，如果发送完数据，确信自己不会再发送，则可以立即调用`CloseWrite`方法：系统**会**向服务端发送`FIN`包，但此时服务端依旧可以向客户端发送数据，客户端也可以从服务端读取数据，都不会有任何报错。但如果客户端调用了`CloseWrite`后，继续向连接中写入数据，则客户端会报错：`write: broken pipe`
		- 对于客户端，如果发送完数据，立即调用了`CloseRead`方法（这通常不合理）：系统**不会**向服务端发送`FIN`包，如果客户端立即从连接中读取数据，则会报错：`EOF`，但如果客户端，稍做停留，等待服务端发送了数据过来，此时再从连接中读取数据，则能正确读取到数据，不会有任何报错。客户端调用`CloseRead`方法后，服务端向客户端发送数据不受影响，不会有任何报错
		- 对于客户端，如果发送完数据，立即调用`Close`方法（这通常不合理）：系统**会**向服务端发送`FIN`包
-
-