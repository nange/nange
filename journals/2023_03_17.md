- [[Rust]] 为什么这么难学？
	- 引入了新概念，如所有权，生命周期等，但这些概念对于一个有经验的程序员，稍加理解其实也是不难的
	- 关键在于新概念也不是万能的，也有其不适用或者缺点：
		- [[所有权]]：
			- 所有权虽然让对象的引用关系变得简单清晰了，也不再需要GC了，但所有权也有其局限性，如在表达有向无环图，链表等数据结构时，由于所有权概念的限制（一个对象只能由一个变量所拥有），无法表达。
			- 为了解决这个问题，Rust又引入了：引入计数型智能指针`Rc`，对象通过`Rc`的包装，就可以让多个变量底层指向一个（堆上）值。语法上，让编译器看上去还是一个变量拥有一个值的，因此没有违背语法上的所有权规则。最终在引用计数变为0时，释放掉堆上的内存。
			- 但`Rc`的使用，又引入了新问题，经过`Rc`包装后，无法修改`Rc`内部的值了。因为它只是一个只读的引用计数器。因此又需要引入一个新的智能指针来解决次问题：`RefCell`。通过`RefCell`包装的值，即使声明的是不可变变量，但是通过调用其`borrow_mut()`方法，也可以获得里层值的可变借用。这样就能修改值了，然后我们外层再包装一个`Rc`，这样就同时实现了，一个值被多个变量拥有，又能修改值内部数据的目的了。
			- 问题还没完呢。。前面我们讨论的都还是单线程情况下，多线程下还得用其线程安全的版本对象包装，`Rc`的安全版本是`Arc`，`RefCell`的安全版本是`Mutex`和`RwLock`。
			- 最终单线程版本是：`Rc<RefCell<T>>` 多线程版本是`Arc<Mutex<T>>`
			- 这样一层套一层后，让学习成本和代码阅读成本都提高了很多，这才是Rust难的地方
		- [[生命周期]]：
			- 生命周期难点在于需要理解为什么需要生命周期，以及生命周期标注的本质是要做什么
			- 生命周期和借用(引用)强相关，因为我们需要确保引用在使用过程中始终是合法的，不会出现使用使用已释放内存的情况
			- 生命周期标注本质上是要建立输入和返回值之间的关系，这个关系和函数内部的实现无关，只和函数的签名有关。结构体同理，是建立字段值和结构体之间的关系。
			- Rust能自动推导一些简单场景的生命周期关系，更多场景需要我们自己标注
		- [[类型系统]]：
			- Rust拥有强大灵活的类型系统。如泛型，生命周期，trait。
			- 泛型的代码本身就相对较难理解了，如果同时加上生命周期(也可以看做泛型的一种形式)，代码将更加难以理解
			- trait统一了Rust中类型的所有行为。如能调用什么方法，能执行什么操作（如加号操作，内存Copy，内存Drop，解引用等等），这从类型系统来说是非常棒的，归一化了所有行为。但凡是都有利弊，由于实际的可能的行为非常多，让trait的使用非常灵活且复杂，系统自带的trait的种类就多入“牛毛”，要缕清这里面的关系非常困难，很容易让初学者迷失在深林中。