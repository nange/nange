- [[Rust]] 为什么这么难学？
	- 引入了新概念，如所有权，生命周期等，但这些概念对于一个有经验的程序员，稍加理解其实也是不难的
	- 关键在于新概念也不是万能的，也有其不适用或者缺点：
		- [[所有权]]：
			- 所有权虽然让对象的引用关系变得简单清晰了，也不再需要GC了，但所有权也有其局限性，如在表达有向无环图，链表等数据结构时，由于所有权概念的限制（一个对象只能由一个变量所拥有），无法表达。
			- 为了解决这个问题，Rust又引入了：引入计数型智能指针`Rc`，对象通过`Rc`的包装，就可以让多个变量底层指向一个（堆上）值。语法上，让编译器看上去还是一个变量拥有一个值的，因此没有违背语法上的所有权规则。最终在引用计数变为0时，释放掉堆上的内存。
			- 但`Rc`的使用，又引入了新问题，经过`Rc`包装后，无法修改`Rc`内部的值了。因为它只是一个只读的引用计数器。因此又需要引入一个新的智能指针来解决次问题：`RefCell`。通过`RefCell`包装的值，即使声明的是不可变变量，但是通过调用其`borrow_mut()`方法，也可以获得里层值的可变借用。这样就能修改值了，然后我们外层再包装一个`Rc`，这样就同时实现了，一个值被多个变量拥有，又能修改值内部数据的目的了。
			- 问题还没完呢。。前面我们讨论的都还是单线程情况下，多线程下还得用其线程安全的版本对象包装，`Rc`的安全版本是`Arc`，`RefCell`的安全版本是`Mutex`和`RwLock`。
			- 最终单线程版本是：`Rc<RefCell<T>>` 多线程版本是`Arc<Mutex<T>>`
			- 这样一层套一层后，让学习成本和代码阅读成本都提高了很多，这才是Rust难的地方
		- [[生命周期]]：
			-