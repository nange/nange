- [[软件设计的哲学]]：**软件发展趋势**
	- 面向对象编程和继承
		- 优点：私有方法和变量可用于确保信息隐藏：类外的任何代码都不能调用私有方法或访问私有变量，因此它们上没有任何外部依赖关系。
		- 缺点：主要来自于类继承。父类和子类通常都访问父类中的类实例变量。这会导致继承层次结构中的类之间的信息泄漏，并且使得在不查看其他类的情况下很难修改层次结构中的一个类。例如，对父类进行更改的开发人员可能需要检查所有子类，以确保所做的更改不会破坏任何内容。同样，如果子类覆盖父类中的方法，则子类的开发人员可能需要检查父类中的实现。在最坏的情况下，程序员将需要完全了解父类下的整个类层次结构，以便对任何类进行更改。
	- 敏捷开发
		- 其思想涉及如何使软件开发更加轻量，灵活和增量。敏捷开发中最重要的元素之一是开发应该是渐进的和迭代的概念。在敏捷方法中，软件系统是通过一系列迭代开发的，每个迭代都添加并评估了一些新功能。每个迭代都包括设计，测试和客户输入。
		- 缺点：敏捷开发的风险之一是它可能导致战术编程。敏捷开发倾向于使开发人员专注于功能，而不是抽象，它鼓励开发人员推迟设计决策，以便尽快生产可运行的软件。
		- 渐进式开发通常是一个好主意，但是**软件开发的增量应该是抽象而不是功能**。
		- 适用场景：更适合变化特别大的场景，例如前端开发，或者后端的业务开发
	- 单元测试
		- 单元测试主要用于证明自己的代码正确性以及为后续的重构增加信心（如果重构完成了还能通过单元测试的话）
		- 系统测试（有时称为集成测试），这些测试可确保应用程序的不同部分都能正常协同工作。它们通常涉及在生产环境中运行整个应用程序。
	- 测试驱动开发
		- 测试驱动开发是一种软件开发方法，程序员可以在编写代码之前先编写单元测试。
		- 缺点：测试驱动开发的问题在于，它将注意力集中在使特定功能起作用，而不是寻找最佳设计上。这是一种纯净而简单的战术编程，具有所有缺点。测试驱动的开发过于增量：在任何时间点，很容易破解下一个功能以进行下一个测试通过。没有明显的时间进行设计，因此很容易陷入混乱。
		- 适用场景：和敏捷开发的适用场景一样。
	- 设计模式
		- 设计模式是解决特定类型问题（例如迭代器或观察器）的常用方法。
		- 设计模式的最大风险是过度使用。使用现有的设计模式并不能完全解决所有问题。当自定义方法更加简洁时，请勿尝试将问题强加到设计模式中。
		- 只有在设计模式合适的情况下才引入设计模式。另外并不是越多越好。
	- 参考资料：[软件发展趋势](https://cactus-proj.github.io/A-Philosophy-of-Software-Design-zh/ch19.html#%E7%AC%AC-19-%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF)
-
- [[软件设计的哲学]]：**为性能设计**
	- 最重要的想法仍然是简单性：简单性不仅可以改善系统的设计，而且通常可以使系统更快。
	- 如何考虑性能：
		- 关键是要了解哪些操作本质上是昂贵的。以下是一些相对昂贵的操作示例：
			- 网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。
			- I/O 到二级存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。
			- 动态内存分配（C 语言中的 malloc， C++ 或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。
			- 高速缓存未命中：从DRAM中提取数据到芯片内的处理器缓存需要几百个指令周期；在许多程序中，整体性能取决于缓存未命中和计算成本。
		- 如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的
		- 如果有明确的证据表明性能在特定情况下很重要，那么您最好立即实施更快的方法。
	- 先度量再修改：
		- 进行任何更改之前，请测量系统的现有行为。
		- 首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉您系统速度太慢，但不会告诉您原因。
		- 测量的第二个目的是提供基线，以便您可以在进行更改后重新测量性能，以确保性能得到实际改善。
	- 围绕关键路径进行设计：
		-