- [[数据库索引]] [[B+树]]：
	- B+树是一种自平衡的树，主要用于数据库和文件系统的索引。它的特点是所有的值都出现在叶子节点上，非叶子节点只存储键值和子树的指针。这使得在查找时，即使在最坏的情况下，也能保证在O(log n)的时间复杂度内找到目标值。
	- 在B+树中，查找操作从根节点开始，根据键值选择一个子节点，然后在该子节点中重复这个过程，直到到达叶子节点。因为B+树是自平衡和高度一定的，所以无论目标值在哪个位置，查找路径的长度都大致相同。这就是为什么B+树的查找操作的时间复杂度是O(log n)。这里的n是树中的键值数量，log n是因为在每一步操作中，我们都在大约减半待查找的键值数量。
	- B+树的结构如下：
		- 根节点：根节点可能是一个叶子节点，也可能是一个内部节点，取决于树的高度。如果树的高度为1，那么根节点就是叶子节点。
		- 内部节点：内部节点包含了键和指向子节点的指针。键用于指示搜索路径，即根据键的值来决定应该沿哪个子节点继续搜索。
		- 叶子节点：叶子节点包含了所有的键值和数据。在B+树中，所有的数据都存储在叶子节点中，且叶子节点之间通过指针相连，形成一个链表结构，便于进行范围查询。
		- 分裂和合并：当一个节点的元素数量超过了最大值（通常是节点的度数(阶数)减1），那么就需要将该节点分裂为两个节点。反之，如果一个节点的元素数量少于最小值（通常是节点的度数的一半），那么就需要通过合并或者重新分配元素来保持树的平衡。
	- B+树的优点：
		- 所有叶子节点包含所有键值和记录，且链表结构便于范围查询。
		- 非叶子只存储键值和指针，因此每个非叶子点，可以包含尽可能多的数据，从而可以提供更多的分支，降低树的高度。
		- 由于所有数据都存储在叶子节点，且叶子节点深度相同，所以查找的性能稳定。
	- B+树的缺点：
		- 插入和删除可能需要大量的磁盘I/O操作，因为可能需要分裂或合并节点。
		- 如果数据的插入和删除非常频繁，可能会导致树的结构频繁变化，影响性能。
	- **问题1：B+树的一个内部节点通常包含多少个键和指针呢？**
		- 这不是一个固定值，是由B+树的度（阶）决定的，由d表示。内部节点的指针数量就是d/2~d之间，键值数量是指针数量减1。超过d，则需要做节点分裂，少于d/2则需要合并或重新分配操作。
		- B+树的度（也称为阶数）的选择主要取决于以下两个因素：
			- 磁盘I/O操作的代价：B+树的设计目标是最小化磁盘I/O操作的次数。每次磁盘I/O操作都会读取一个磁盘块的数据。因此，通常会选择一个度，使得一个节点的大小正好等于一个磁盘块的大小。这样，每次磁盘I/O操作就可以读取一个节点的所有数据。
			- 树的高度：B+树的度越大，树的高度越低。树的高度直接影响了查找、插入和删除操作的速度。因为每次操作都需要从根节点开始，沿着树向下搜索，所以树的高度越低，操作的速度就越快。
		- InnoDB索引的度并不是固定的，而是根据页的大小来动态确定的。InnoDB存储引擎的默认页大小是16KB，但是可以配置为1KB、2KB、4KB、8KB、16KB、32KB或64KB。一个页的大小决定了InnoDB索引的度。具体来说，InnoDB会尽可能地在一个页中存储尽可能多的键和指针，直到达到页的大小。
			- 假设键值是int64的类型，那么大概计算一下默认情况下，一个内部节点最大包含的键值数大致为：(16 * 1024) / (8 * 2) = 1024 再加上内部节点还有一些元信息还要占用部分空间，大致上就包含不超过1000个键值和指针。
		- 也就是InnoDB中，一个页的大小就是一个内部节点的大小。
	- **问题2： 内部节点中的键值顺序关系是怎么样的？键值和指针的关系是什么？指针指向的是什么？**
		- 在B+树的内部节点中，键值是按照升序排列的。每个键值都对应两个指针，一个指向键值左边的子树，一个指向键值右边的子树。
		- 具体来说，如果我们有一个内部节点，它的键值是K1、K2、K3，那么它会有四个指针P1、P2、P3、P4。这四个指针指向的子树中的键值满足以下条件：
			- P1指向的子树中的所有键值都小于K1。
			- P2指向的子树中的所有键值都大于等于K1，但小于K2。
			- P3指向的子树中的所有键值都大于等于K2，但小于K3。
			- P4指向的子树中的所有键值都大于等于K3。
		- 这样的设计使得我们可以通过比较键值和搜索关键字，确定应该在哪个子树中继续搜索，从而有效地减少搜索的时间复杂度。
		- 指针实际上是分别指向其他页的地址。如果这个页是内部节点，那么它会包含更多的键值和指针；如果这个页是叶子节点，那么它会包含实际的数据记录。
-