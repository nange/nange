- [[数据库索引]] [[静态散列(Hash)]]：
	- 它使用哈希函数将键（通常是数据库表中的特定列）转换为哈希码，然后对哈希码取余得到对应的“桶”，然后在“桶”中再查找相应的数据。
	- “桶”是存储数据的单位，通常对应一个或多个磁盘块。
	- “桶”中的数据组织形式通常是数组、链表、B+树等；通常是排好序的。
- [[数据库索引]] [[动态散列(Hash)]]：
	- 常见的一种动态哈希算法是：扩展哈希（Extendible Hashing）
		- 其核心思路是通过使用一个全局深度（Global Depth）和每个桶的局部深度（Local Depth）来动态地调整哈希桶的数量。
		- 当局部深度小于全局深度时，扩展只发生在桶内部，即临时将此桶的容量增加，同时局部深度加1
		- 当局部深度达到全局深度时，需要将全局深度加1，并按新的全局深度分配新的桶数量，通常是2^n。并且此时需要重分配所有键值。
		- 此算法一定程度上解决了扩展的问题，但还是会出现大量数据重分配，对IO和CPU消耗很大
	- **我想到一种新的改进的动态哈希算法：**
		- 核心构想：桶分为两类，即物理桶和逻辑桶。
			- 先根据系统预估初始化一个大部分场景都合适的桶数量。如16，初始化的桶类型都是物理桶。
			- 键值插入和一般的静态哈希算法一致，即根据键，计算哈希，找到对应的桶进行插入。
			- 继续插入，当发现某个顶层的物理桶满时，把此桶类型修改为逻辑桶，内部再将此桶一分为二为两个物理桶，但从最顶层来看，总的桶数量还是16，并不会发生改变。在这个逻辑桶内部，一分为二成两个物理桶后，需要将原来的这个物理桶数据重分配到这两个新的物理桶中，重分配的算法还是和插入一样，对键重新计算哈希，从而决定应该分配到哪个桶中。输入插入此逻辑桶的算法也是类似的，在外部决定要插入此逻辑桶，在逻辑桶内部再对键计算一次哈希，决定该写入哪个物理桶。
			- 物理桶转逻辑桶的算法是可以递归进行的，如果数据量很大，持续需要扩展桶的话。
		- 这个算法的最大优势是，不会发生全局的键值重分配，每次扩展都发生在一个桶内部，只是局部的数据重分配。
		-