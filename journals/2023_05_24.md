- [[软件设计的哲学]]：**不同的层，不同的抽象**
	- 软件系统由层组成，其中较高的层使用较低层提供的功能。在设计良好的系统中，每一层都提供与其上，下两层不同的抽象。
	- 当相邻的层具有相似的抽象时。即上层几乎不会做额外的工作，直接调用下层的方法，方法签名也相同。这被称为直通方法。
		- 出现较多这种情况，则表明层之间的责任划分存在混淆
		- 解决方案是重构层，以使每个层都有各自不同且连贯的职责
			- ![](https://cactus-proj.github.io/A-Philosophy-of-Software-Design-zh/assets/00015.40c96482.jpeg)
			- 一种方法，如图 （b）所示，将较低级别的类直接暴露给较高级别的类的调用者，而从较高级别的类中删除对该功能的所有责任。
			- 另一种方法是在类之间重新分配功能，如图（c）所示。
			- 最后，如果无法解开这些类，最好的解决方案可能是如图 7.1（d）所示合并它们。
	- 具有相同签名的方法并不总是不好的。重要的是，每种新方法都应贡献重要的功能。直通方法很糟糕，因为它们不提供任何新功能。
		- 一个方法调用另一个具有相同签名的方法很有用的例子是调度器。
		- 例如：当 Web 服务器从 Web 浏览器接收到传入的 HTTP 请求时，它将调用一个调度器来检查传入请求中的 URL 并选择一种特定的方法来处理该请求。
		- 某些 URL 可以通过返回磁盘上文件的内容来处理；其他的则可能通过调用诸如 PHP 或 JavaScript 之类的语言的程序来处理。分发过程可能非常复杂，通常由与传入 URL 匹配的一组规则来驱动。
	- 装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。
		- 但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。
		- 创建装饰器类之前，请考虑以下替代方法：
			- 能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。
			- 如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否更好？
			- 可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？
			- 新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？
	- 传递变量：跨层 API 重复的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。
		- 增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量，此外，如果存在一个新变量。
		- 传递变量的最佳实践是：引入一个上下文对象。
			- 上下文存储应用程序的所有全局状态；
			- 大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容；
			- 在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。
			- 上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；
	- 参考资料：[不同的层，不同的抽象](https://cactus-proj.github.io/A-Philosophy-of-Software-Design-zh/ch07.html#_7-1-pass-through-methods-%E7%9B%B4%E9%80%9A%E6%96%B9%E6%B3%95)