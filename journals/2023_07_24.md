- [[Linux性能优化]] [[不可中断进程和僵尸进程]]：
	- 进程状态：`top`命令里面的S列
		- R：Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。
		- D：Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
		- Z：Zombie 的缩写，表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
		- S：Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。
		- I： Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。
		- T 或者 t：也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；而用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态。
	- 当 `iowait` 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。从 ps 或者 top 命令的输出中，它们都处于 D 状态。
	- **如何分析iowait 升高原因：**
		- 从`top`命令可以看到系统的iowait异常，可推断，这大概率和磁盘交互有关。
		- 使用`dstat`命令可以同时观察到CPU、磁盘、网络、系统中断和上下文切换数据。从`dstat`可以观察到iowait升高和磁盘读写之间的关系。确认是否是读、写还是读写同时影响。
		- 进一步确认是哪个进程引起的iowait升高：
			- 处于iowait状态的进程很可能处于`D`状态，可从`top`命令中，大致推断出是哪个进程。
			- 通过`pidstat`命令可以进一步确认进程，加上`-d`参数可以看到io情况。
		- 找到是哪个进程引起的iowait后，还可以进一步找出进程在执行啥IO操作：
			- 进程要访问磁盘，就必须使用系统调用。我们想办法找出进程的具体的哪个系统调用引起的问题。
			- `strace`是最常用的跟踪进程系统调用的工具。
			- 前面我们已经找到了进程号，现在执行：`strace -p <进程号>`，会打印具体的系统调用
		- 如果是那种短时进程引起的，用strace去分析时，可能进程已经退出了，就没法分析，此时可以使用前面提到过的`perf record -g`进行动态跟踪记录，同样可以找出具体的系统调用。
		- 进一步确认之后，可以结合代码分析问题了。
	- **如何解决僵尸进程多的问题：**
		- 僵尸进程根源是因为父进程没有回收子进程的资源而出现的，要解决掉它们，也就是找出父进程，然后在父进程里解决。
		- 前面提到过的`pstree`就是找父进程的，示例：
			- ```
			  # -a 表示输出命令行选项
			  # p表PID
			  # s表示指定进程的父进程
			  $ pstree -aps 3084
			  systemd,1
			    └─dockerd,15006 -H fd://
			        └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml
			            └─docker-containe,3991 -namespace moby -workdir...
			                └─app,4009
			                    └─(app,3084)
			  ```
			- 这样就找出了3084的父进程是4009，也就是app进程。
		- 找到对应进程后，就可以在相关代码的创建子进程的地方进行修复。